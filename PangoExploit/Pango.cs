namespace PangoExploit
{
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.ComponentModel.Composition;
    using System.Linq;
    using System.Threading;
    using System.Threading.Tasks;

    using Ensage;
    using Ensage.Common.Menu;
    using Ensage.SDK.Abilities.npc_dota_hero_pangolier;
    using Ensage.SDK.Extensions;
    using Ensage.SDK.Handlers;
    using Ensage.SDK.Helpers;
    using Ensage.SDK.Menu;
    using Ensage.SDK.Service;
    using Ensage.SDK.Service.Metadata;

    [ExportPlugin("Pango Exploit", HeroId.npc_dota_hero_pangolier)]
    internal class Pango : Plugin
    {
        private readonly Unit owner;

        private readonly Dictionary<Hero, float> rotations = new Dictionary<Hero, float>();

        private readonly pangolier_swashbuckle swashbuckle;

        private MenuItem<Slider> damageMult;

        private MenuItem<KeyBind> escape;

        private MenuItem<bool> killSteal;

        private MenuFactory menu;

        private TaskHandler taskHandler;

        private MenuItem<Slider> turnTime;

        [ImportingConstructor]
        public Pango(IServiceContext context)
        {
            owner = context.Owner;
            swashbuckle = context.AbilityFactory.GetAbility<pangolier_swashbuckle>();
        }

        protected override void OnActivate()
        {
            menu = MenuFactory.CreateWithTexture("Pango", owner.Name);
            escape = menu.Item("Escape key", new KeyBind('F'));
            escape.PropertyChanged += OnPropertyChanged;
            killSteal = menu.Item("Kill steal", true);
            turnTime = menu.Item("Turn time check", new Slider(400, 0, 1000));
            damageMult = menu.Item("Damage multiplier", new Slider(90, 50, 150));
            killSteal.PropertyChanged += KillStealOnPropertyChanged;
            Player.OnExecuteOrder += PlayerOnExecuteOrder;
            Entity.OnInt32PropertyChange += EntityOnInt32PropertyChange;
            taskHandler = new TaskHandler(KillSteal, true);
            if (killSteal)
            {
                taskHandler.RunAsync();
            }
        }

        protected override void OnDeactivate()
        {
            escape.PropertyChanged -= OnPropertyChanged;
            Player.OnExecuteOrder -= PlayerOnExecuteOrder;
            killSteal.PropertyChanged -= KillStealOnPropertyChanged;
            Entity.OnInt32PropertyChange -= EntityOnInt32PropertyChange;
            taskHandler.Cancel();
            menu.Dispose();
        }

        private void EntityOnInt32PropertyChange(Entity sender, Int32PropertyChangeEventArgs args)
        {
            if (args.NewValue == args.OldValue || args.PropertyName != "m_anglediff")
            {
                return;
            }

            var enemy = sender as Hero;
            if (enemy == null || enemy.IsAlly(owner))
            {
                return;
            }

            rotations[enemy] = Game.RawGameTime;
        }

        private float GetRotationTime(Hero hero)
        {
            float rotationTime;
            if (!rotations.TryGetValue(hero, out rotationTime))
            {
                rotationTime = Game.RawGameTime;
                rotations[hero] = rotationTime;
            }

            return rotationTime;
        }

        private async Task KillSteal(CancellationToken token)
        {
            try
            {
                if (Game.IsPaused || !owner.IsAlive || !swashbuckle.CanBeCasted)
                {
                    return;
                }

                var enemy = EntityManager<Hero>.Entities
                    .Where(
                        x => x.IsValid && x.IsVisible && x.IsAlive && x.IsEnemy(owner) && !x.IsIllusion && !x.IsInvulnerable()
                             && GetRotationTime(x) + (turnTime / 1000f) <= Game.RawGameTime)
                    .FirstOrDefault(x => swashbuckle.GetDamage(x) * (damageMult / 100f) > x.Health);

                if (enemy == null)
                {
                    return;
                }

                swashbuckle.Ability.TargetPosition(enemy.InFront(-250));
                swashbuckle.Ability.TargetPosition(enemy.InFront(150));
                swashbuckle.Ability.UseAbility(owner.Position);

                await Task.Delay(2000, token);
            }
            catch
            {
            }
        }

        private void KillStealOnPropertyChanged(object sender, PropertyChangedEventArgs propertyChangedEventArgs)
        {
            if (killSteal)
            {
                taskHandler.RunAsync();
            }
            else
            {
                taskHandler.Cancel();
            }
        }

        private void OnPropertyChanged(object sender, PropertyChangedEventArgs propertyChangedEventArgs)
        {
            if (!escape || !swashbuckle.CanBeCasted)
            {
                return;
            }

            var fountain = EntityManager<Unit>.Entities.FirstOrDefault(x => x.IsValid && x.IsAlly(owner) && x.Name == "dota_fountain");
            if (fountain == null || fountain.Distance2D(owner) < 2000)
            {
                return;
            }

            swashbuckle.Ability.TargetPosition(owner.Position.Extend(fountain.Position, swashbuckle.CastRange));
            swashbuckle.Ability.TargetPosition(owner.Position.Extend(fountain.Position, swashbuckle.Range / 2));
            swashbuckle.Ability.UseAbility(owner.Position);
        }

        private void PlayerOnExecuteOrder(Player sender, ExecuteOrderEventArgs args)
        {
            if (!args.Entities.Contains(owner) || args.OrderId != OrderId.AbilityLocation || !args.IsPlayerInput
                || args.Ability.Id != swashbuckle.Ability.Id)
            {
                return;
            }

            swashbuckle.Ability.UseAbility(owner.Position);
            args.Process = false;
        }
    }
}